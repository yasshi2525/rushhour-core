# é‰„é“ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«

ã‚²ãƒ¼ãƒ ã®è¦ä»¶ã«å¿…è¦ãªé‰„é“ã®æ§‹é€ ã‚’å®šç¾©ã™ã‚‹ã€‚

## ã‚²ãƒ¼ãƒ ä¸­ã®é‰„é“ã«æ±‚ã‚ã‚‰ã‚Œã‚‹è¦ä»¶

### å…¨ä½“

* é‰„é“ã¯ç·šè·¯ã€é§…ã€é›»è»Šã‹ã‚‰æ§‹æˆã•ã‚Œã‚‹ã€‚
* é‰„é“ã®å»ºè¨­ãƒ»æ’¤å»ã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒè¡Œã†ã€‚
* ä»–äººãŒå»ºè¨­ã—ãŸé‰„é“ã¯ã€é–²è¦§ã§ãã‚‹ãŒæ“ä½œã§ããªã„ã€‚
* é‰„é“ã®å»ºè¨­ãƒ»æ’¤å»ã«ã¯ã‚³ã‚¹ãƒˆï¼ˆãŠé‡‘ï¼‰ãŒã‹ã‹ã‚‹ã€‚
* å»ºè¨­ã—ãŸé‰„é“ã¯ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨å£²è²·ã§ãã‚‹ã€‚
* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã‚¹ãƒ ãƒ¼ã‚ºã«ã‚²ãƒ¼ãƒ ã«å…¥ã‚Œã‚‹ã‚ˆã†ã€ã‚ã‚‰ã‹ã˜ã‚æ§‹ç¯‰ã•ã‚ŒãŸã€èª°ã«ã‚‚æ‰€å±ã—ãªã„é‰„é“ã‚‚å­˜åœ¨ã™ã‚‹ã€‚

åˆ—è»Šãƒ»é›»è»Šã®ç”¨èªã«ã¤ã„ã¦ã¯é›»è»Šã«çµ±ä¸€ã™ã‚‹ã€‚ã‚ˆã‚Šåºƒç¯„ãªæ„å‘³ã®åˆ—è»Šã¯ç¾æ™‚ç‚¹ã§ã¯ä½¿ã‚ãªã„ã€‚
æ—…å®¢è¼¸é€ã‚’ã‚¹ã‚³ãƒ¼ãƒ—ã¨ã—ã€è²¨ç‰©è¼¸é€ã¯ã‚¹ã‚³ãƒ¼ãƒ—å¤–ã¨ã™ã‚‹ã€‚

### ç·šè·¯

* ç·šè·¯ã¯æ›²ç·šã‹ã‚‰æ§‹æˆã•ã‚Œã‚‹ã€‚
* ç·šè·¯ã¯åˆ†å²ãƒ»äº¤å·®ãƒ»åˆæµã•ã›ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
* ç·šè·¯ã¯ä»»æ„ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§è¨­ç½®ãƒ»æ’¤å»ã§ãã‚‹ã€‚
* ãƒªã‚¢ãƒªãƒ†ã‚£ã¨ã‚²ãƒ¼ãƒ æ€§ã‚’æãªã‚ã›ãªã„ãŸã‚ã€æ¥µç«¯ã«è¿‘ã„å ´æ‰€ã«ç·šè·¯ã‚’ä¸¦è¡Œã•ã›ã‚‹ã“ã¨ã¯ã§ããªã„ã€‚
* é›»è»Šã®è¡çªå›é¿å®Ÿç¾ã®ãŸã‚ã€ä¿¡å·æ©Ÿã‚’é…ç½®ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
* ä»–äººãŒè¨­ç½®ã—ãŸç·šè·¯ã«æ¥ç¶šã•ã›ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚ãŸã ã—ã“ã‚Œã¯å°†æ¥ã‚’è¦‹æ®ãˆãŸä»•æ§˜ã§ã€ç¾æ™‚ç‚¹ã§ã¯ç¦æ­¢ã™ã‚‹ã€‚

### é§…

* é§…ã¯ç·šè·¯ã«éš£æ¥ã—ã¦å­˜åœ¨ã™ã‚‹
* é§…ã¯åˆ©ç”¨å®¢ãŒå‡ºå…¥ã‚Šã™ã‚‹æ”¹æœ­ã¨é›»è»Šã«å‡ºå…¥ã‚Šã§ãã‚‹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ï¼ˆãƒ›ãƒ¼ãƒ ï¼‰ã¨ã“ã‚Œã‚‰ã‚’çµã¶é€šè·¯ã‹ã‚‰æ§‹æˆã•ã‚Œã‚‹ã€‚
* æ”¹æœ­ã‚’é€šã‚‹ã®ã«ä¸€å®šã®æ™‚é–“ã‚’è¦ã™ã‚‹ã€‚
* æ”¹æœ­ãŒä¸€æ¯ã®å ´åˆã€åˆ©ç”¨å®¢ã¯åˆ—ã‚’æˆã—ã¦å¾…ã¤ã€‚
* ãƒ›ãƒ¼ãƒ ã«ã¯åå®¹å¯èƒ½ãªå®šå“¡ãŒå­˜åœ¨ã™ã‚‹ã€‚
* é€šè·¯ã¨ãƒ›ãƒ¼ãƒ ã¯äººæ•°ãŒå¤šã„ã»ã©ç§»å‹•é€Ÿåº¦ãŒä½ä¸‹ã™ã‚‹ã€‚
* é§…ã¯è¤‡æ•°ã®æ”¹æœ­ã€ãƒ›ãƒ¼ãƒ ã‚’æŒã¦ã‚‹ãŒã€ã‚²ãƒ¼ãƒ æ€§ã‚’æãªã‚ã›ãªã„ã‚ˆã†ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯æ¥µç«¯ã«é›¢ã‚ŒãŸå ´æ‰€ã«è¨­ç½®ã§ããªã„ã€‚
* ä»–äººã®ç·šè·¯ã¨ã®å¢ƒç•Œç‚¹ã«å…±åŒæ‰€æœ‰ã®é§…ã‚’ä½œã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚ãŸã ã—ã“ã‚Œã¯å°†æ¥ã‚’è¦‹æ®ãˆãŸä»•æ§˜ã§ã€ç¾æ™‚ç‚¹ã§ã¯ç¦æ­¢ã™ã‚‹ã€‚

### é›»è»Š

* é›»è»Šã¯ç·šè·¯ã®ä¸Šã‚’èµ°ã‚Šã€é§…ã«åœè»Šãƒ»é€šéã™ã‚‹
* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯é›»è»Šã‚’ä»»æ„ã®ç·šè·¯ä¸Šã«é…ç½®ã—ãŸã‚Šã€æ’¤å»ã§ãã‚‹ã€‚
* ã‚ã‚‹ç·šè·¯ã®ä¸Šã¯æœ€å¤§ã§ã‚‚1å°ã®é›»è»Šã—ã‹å­˜åœ¨ã§ããªã„ã€‚
* é›»è»Šã¯ç‰©ç†çš„å¤§ãã•ã‚’æŒã¤ã€‚ç·¨æˆé•·ã®åˆ†ã€ç·šè·¯ã‚’å æœ‰ã™ã‚‹ã€‚
* é›»è»Šã¯æ±ºã¾ã£ãŸçµŒè·¯ã«å¾“ã£ã¦ç·šè·¯ä¸Šã‚’èµ°ã‚‹ã€‚
* é›»è»Šã®çµŒè·¯ã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå®šç¾©ã§ãã‚‹ã€‚
* é›»è»Šã¯åˆ©ç”¨å®¢ã‚’ä¹—ã›ã¦ç§»å‹•ã™ã‚‹ã€‚
* é›»è»Šã¯åˆ©ç”¨å®¢ã®ä¹—é™ãŒã™ã¹ã¦çµ‚ã‚ã‚‹ã¾ã§é§…ã‚’ç™ºè»Šã§ããªã„ã€‚
* åˆ©ç”¨å®¢ãŒä¸€åº¦ã«ä¹—ã‚Šé™ã‚Šã§ãã‚‹äººæ•°ã¯ãƒ‰ã‚¢æ•°ã«ã‚ˆã£ã¦æ±ºã¾ã‚‹ã€‚
* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é‹è¡Œè¨ˆç”»å®šç¾©ã«ã‚ˆã‚Šã€é›»è»Šã¯ã‚ã‚‹åŒºé–“ã€åˆ©ç”¨å®¢ã‚’è¼‰ã›ãšã«èµ°ã‚‹å›é€é‹è»¢ã‚’è¡Œã†ã“ã¨ãŒã§ãã‚‹ã€‚
* é›»è»Šã¯è­˜åˆ¥ã¨é‹ç”¨ã®ç…©é›‘ã•ã‚’é¿ã‘ã‚‹ãŸã‚ã€ç¨®åˆ¥ï¼ˆæ™®é€šã€å¿«é€Ÿã€ç‰¹æ€¥ãªã©ï¼‰ã‚’ã‚‚ãŸã›ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚ç¨®åˆ¥ã«ã¯å„ªåŠ£ãŒã‚ã‚‹ã€‚
* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ€ã‚¤ãƒ¤å®šç¾©ã‚’åŠ¹ç‡åŒ–ã™ã‚‹ãŸã‚ã€åŒç­‰ã®é‹è¡Œè¨ˆç”»ã‚’æŒã¤é›»è»Šã‚°ãƒ«ãƒ¼ãƒ—ã‚’å®šç¾©ã§ãã‚‹ã€‚
* ä¸‹ä½ç¨®åˆ¥ã®é›»è»Šã¯ã€é€€é¿å¯èƒ½ãªé§…ã§å¾Œç¶šã®ä¸Šä½ç¨®åˆ¥ã‚’é€€é¿ã™ã‚‹ã€‚
* å…ˆè¡Œé›»è»Šã«è¿‘ã¥ãã™ãã‚‹ã¨ã€è¡çªå›é¿ã®ãŸã‚ã«é›»è»Šã¯æ¸›é€Ÿãƒ»åœè»Šã™ã‚‹ã€‚
* é›»è»Šã¯ä¿¡å·æ©Ÿã®æŒ‡ç¤ºã«å¾“ã†ã€‚ï¼ˆä¿¡å·æ©Ÿã¯ç¾æ™‚ç‚¹ã§ã¯è¡çªå›é¿ã®ãŸã‚ã®æ‰‹æ®µï¼‰
* ç·šè·¯ã®ã‚«ãƒ¼ãƒ–ãŒãã¤ããªã‚Œã°ãªã‚‹ã»ã©ã€é›»è»Šã®æœ€å¤§èµ°è¡Œé€Ÿåº¦ã¯ä¸‹ãŒã‚‹ã€‚
* é›»è»Šã¯1å°ä»¥ä¸Šã®è»Šä½“ã‹ã‚‰æ§‹æˆã•ã‚Œã‚‹ï¼ˆä¸¡æ•°ï¼‰ã€‚
* è»Šä½“ã«ã¯ä¹—è»Šå¯èƒ½ãªå®šå“¡ãŒå­˜åœ¨ã™ã‚‹ã€‚
* é›»è»Šã¯ä¸¡æ•°ã‚„ãƒ‰ã‚¢æ•°ã‚’å¢—ã‚„ã—ãŸã‚Šã€åŠ é€Ÿæ€§èƒ½ã€æœ€å¤§èµ°è¡Œé€Ÿåº¦ã‚’å‘ä¸Šã•ã›ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
* é›»è»Šã¯ä»–äººãŒè¨­ç½®ã—ãŸç·šè·¯ã®ä¸Šã‚’èµ°ã£ãŸã‚Šã€é§…ã«åœè»Šã§ãã‚‹ã€‚ãŸã ã—ã€ã“ã‚Œã¯å°†æ¥ã‚’è¦‹æ®ãˆãŸä»•æ§˜ã§ã€ç¾æ™‚ç‚¹ã§ã¯ç¦æ­¢ã™ã‚‹ã€‚

## è¦ä»¶ã®ã‚°ãƒ«ãƒ¼ãƒ—åˆ†ã‘ã¨æ•´ç†

### 1. åŸºç›¤ã‚·ã‚¹ãƒ†ãƒ è¦ä»¶

#### 1.1 å…¨ä½“ã‚·ã‚¹ãƒ†ãƒ è¦ä»¶
* é‰„é“ã¯ç·šè·¯ã€é§…ã€é›»è»Šã‹ã‚‰æ§‹æˆã•ã‚Œã‚‹
* é‰„é“ã®å»ºè¨­ãƒ»æ’¤å»ã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒè¡Œã†ï¼ˆã‚³ã‚¹ãƒˆè¨­å®šã‚ã‚Šï¼‰
* ä»–äººãŒå»ºè¨­ã—ãŸé‰„é“ã¯é–²è¦§å¯èƒ½ã ãŒæ“ä½œä¸å¯
* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é–“ã§ã®é‰„é“å£²è²·æ©Ÿèƒ½
* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å°å…¥æ”¯æ´ç”¨ã®æ—¢å­˜é‰„é“ï¼ˆç„¡æ‰€å±ï¼‰ã®å­˜åœ¨
* **åˆ†æ•£å‡¦ç†å¯¾å¿œ**: ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç’°å¢ƒã§ã®åŒæ™‚æ“ä½œåˆ¶å¾¡
* **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åŒæœŸ**: ä½ç½®æƒ…å ±é…ä¿¡å‡¦ç†ã€ä½æ°‘ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å‡¦ç†

#### 1.2 ç”¨èªãƒ»ã‚¹ã‚³ãƒ¼ãƒ—å®šç¾©
* é›»è»Šç”¨èªã¸ã®çµ±ä¸€ï¼ˆåˆ—è»Šã¯ä½¿ç”¨ã—ãªã„ï¼‰
* æ—…å®¢è¼¸é€ã®ã¿å¯¾å¿œï¼ˆè²¨ç‰©è¼¸é€ã¯å¯¾è±¡å¤–ï¼‰

### 2. ç·šè·¯ã‚·ã‚¹ãƒ†ãƒ è¦ä»¶

#### 2.1 åŸºæœ¬æ§‹é€ 
* ç·šè·¯ã¯æ›²ç·šã‹ã‚‰æ§‹æˆã•ã‚Œã‚‹
* åˆ†å²ãƒ»äº¤å·®ãƒ»åˆæµæ©Ÿèƒ½
* ä»»æ„ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ã®è¨­ç½®ãƒ»æ’¤å»
* **è¡çªæ¤œçŸ¥ã‚·ã‚¹ãƒ†ãƒ **: æ¥µç«¯ã«è¿‘ã„ä¸¦è¡Œç·šè·¯ã®ç¦æ­¢åˆ¶å¾¡

#### 2.2 ä¿¡å·ãƒ»åˆ¶å¾¡ã‚·ã‚¹ãƒ†ãƒ 
* ä¿¡å·æ©Ÿé…ç½®ã«ã‚ˆã‚‹è¡çªå›é¿ã‚·ã‚¹ãƒ†ãƒ 
* **åˆ†æ•£å‡¦ç†å¯¾å¿œ**: ä¿¡å·åˆ¶å¾¡å‡¦ç†ã®åˆ†é›¢
* **å®‰å…¨æ€§æœ€å„ªå…ˆ**: é–‰å¡åˆ¶å¾¡ã¨ãƒˆãƒ¼ã‚¯ãƒ³ãƒ™ãƒ¼ã‚¹ç®¡ç†

#### 2.3 æ¥ç¶šãƒ»æ‹¡å¼µæ©Ÿèƒ½
* ä»–äººã®ç·šè·¯ã¸ã®æ¥ç¶šæ©Ÿèƒ½ï¼ˆå°†æ¥ä»•æ§˜ã€ç¾æ™‚ç‚¹ã§ã¯ç¦æ­¢ï¼‰

### 3. é§…ã‚·ã‚¹ãƒ†ãƒ è¦ä»¶

#### 3.1 æ§‹é€ ãƒ»æ©Ÿèƒ½è¦ä»¶
* ç·šè·¯éš£æ¥é…ç½®
* æ”¹æœ­ãƒ»ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ãƒ»é€šè·¯ã®ä¸‰è¦ç´ æ§‹æˆ
* æ”¹æœ­é€šéæ™‚é–“ã®è¨­å®š
* æ”¹æœ­æº€æ¯æ™‚ã®å¾…æ©Ÿåˆ—å‡¦ç†

#### 3.2 å®¹é‡ãƒ»æ€§èƒ½è¦ä»¶
* ãƒ›ãƒ¼ãƒ å®šå“¡åˆ¶é™
* äººæ•°å¢—åŠ ã«ã‚ˆã‚‹ç§»å‹•é€Ÿåº¦ä½ä¸‹
* **ç©ºé–“åˆ†å‰²ã‚·ã‚¹ãƒ†ãƒ **: é§…æ§‹å†…ã®åŠ¹ç‡çš„ãªäººæµç®¡ç†

#### 3.3 æ‹¡å¼µæ€§è¦ä»¶
* è¤‡æ•°æ”¹æœ­ãƒ»ãƒ›ãƒ¼ãƒ å¯¾å¿œ
* æ¥µç«¯ã«é›¢ã‚ŒãŸå ´æ‰€ã¸ã®è¨­ç½®åˆ¶é™
* å…±åŒæ‰€æœ‰é§…æ©Ÿèƒ½ï¼ˆå°†æ¥ä»•æ§˜ã€ç¾æ™‚ç‚¹ã§ã¯ç¦æ­¢ï¼‰

### 4. é›»è»Šã‚·ã‚¹ãƒ†ãƒ è¦ä»¶

#### 4.1 åŸºæœ¬é‹è¡Œè¦ä»¶
* ç·šè·¯ä¸Šèµ°è¡Œãƒ»é§…åœè»Šãƒ»é€šéæ©Ÿèƒ½
* ä»»æ„é…ç½®ãƒ»æ’¤å»æ©Ÿèƒ½
* ç·šè·¯ã‚ãŸã‚Šæœ€å¤§1å°ã®åˆ¶é™
* **ç‰©ç†æ¼”ç®—**: ç·¨æˆé•·ã«ã‚ˆã‚‹ç·šè·¯å æœ‰é¢ç©ã®è¨ˆç®—

#### 4.2 çµŒè·¯ãƒ»é‹è¡Œåˆ¶å¾¡è¦ä»¶
* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å®šç¾©çµŒè·¯ã‚·ã‚¹ãƒ†ãƒ 
* **çµŒè·¯æ¢ç´¢å‡¦ç†**: A*ãƒ»ãƒ€ã‚¤ã‚¯ã‚¹ãƒˆãƒ©æ³•ã«ã‚ˆã‚‹æœ€é©çµŒè·¯è¨ˆç®—
* åˆ©ç”¨å®¢å®Œå…¨ä¹—é™ã¾ã§ç™ºè»Šå¾…æ©Ÿ
* ãƒ‰ã‚¢æ•°ã«ã‚ˆã‚‹ä¹—é™äººæ•°åˆ¶é™

#### 4.3 é‹è¡Œè¨ˆç”»ãƒ»ç¨®åˆ¥è¦ä»¶
* å›é€é‹è»¢æ©Ÿèƒ½
* é›»è»Šç¨®åˆ¥ã‚·ã‚¹ãƒ†ãƒ ï¼ˆæ™®é€šãƒ»å¿«é€Ÿãƒ»ç‰¹æ€¥ç­‰ï¼‰
* **ãƒ€ã‚¤ãƒ¤ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°å‡¦ç†**: æ™‚åˆ»è¡¨ç®¡ç†ãƒ»é…å»¶è¨ˆç®—
* é›»è»Šã‚°ãƒ«ãƒ¼ãƒ—ã«ã‚ˆã‚‹åŠ¹ç‡çš„ãƒ€ã‚¤ãƒ¤ç®¡ç†
* é€€é¿ã‚·ã‚¹ãƒ†ãƒ ï¼ˆä¸‹ä½ç¨®åˆ¥ã®ä¸Šä½ç¨®åˆ¥é€€é¿ï¼‰

#### 4.4 å®‰å…¨ãƒ»åˆ¶å¾¡è¦ä»¶
* **è¡çªæ¤œçŸ¥ãƒ»å›é¿ã‚·ã‚¹ãƒ†ãƒ **: å…ˆè¡Œé›»è»Šæ¥è¿‘æ™‚ã®æ¸›é€Ÿãƒ»åœè»Š
* ä¿¡å·æ©ŸæŒ‡ç¤ºã¸ã®å¾“é †
* **ç‰©ç†æ¼”ç®—**: ã‚«ãƒ¼ãƒ–é€Ÿåº¦åˆ¶é™ã‚·ã‚¹ãƒ†ãƒ 

#### 4.5 è»Šä¸¡æ€§èƒ½ãƒ»ä»•æ§˜è¦ä»¶
* è¤‡æ•°è»Šä½“æ§‹æˆï¼ˆä¸¡æ•°ï¼‰
* è»Šä½“å®šå“¡åˆ¶é™
* æ€§èƒ½å‘ä¸Šã‚·ã‚¹ãƒ†ãƒ ï¼ˆä¸¡æ•°ãƒ»ãƒ‰ã‚¢æ•°ãƒ»åŠ é€Ÿæ€§èƒ½ãƒ»æœ€å¤§é€Ÿåº¦ï¼‰
* ä»–äººç·šè·¯ä¹—ã‚Šå…¥ã‚Œæ©Ÿèƒ½ï¼ˆå°†æ¥ä»•æ§˜ã€ç¾æ™‚ç‚¹ã§ã¯ç¦æ­¢ï¼‰

### 5. è¿½åŠ ã‚·ã‚¹ãƒ†ãƒ è¦ä»¶ï¼ˆä»–ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‹ã‚‰æ¤œè¨¼ï¼‰

#### 5.1 ä½æ°‘ã‚·ã‚¹ãƒ†ãƒ è¦ä»¶
* **ä½æ°‘AI**: 1ä¸‡-50ä¸‡äººã®çµŒè·¯æ¢ç´¢å‡¦ç†
* **TravelPlan**: ç™ºè»Šåœ°ãƒ»ç›®çš„åœ°ãƒ»å‡ºç™ºæ™‚åˆ»ãƒ»å„ªå…ˆè·¯ç·šç®¡ç†
* **PersonalInfoãƒ»EconomicStatus**: ä½æ°‘ã®å€‹äººãƒ»çµŒæ¸ˆæƒ…å ±ç®¡ç†

#### 5.2 åˆ†æ•£å‡¦ç†è¦ä»¶
* **ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹åŒ–**: èª­ã¿å–ã‚Šå°‚ç”¨ã‚µãƒ¼ãƒ“ã‚¹ï¼ˆçµŒè·¯æ¢ç´¢ãƒ»çµ±è¨ˆãƒ»ãƒãƒƒãƒ—ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ï¼‰
* **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚µãƒ¼ãƒ“ã‚¹**: ãƒ–ãƒ­ãƒ¼ãƒ‰ã‚­ãƒ£ã‚¹ãƒˆãƒ»æ™‚åˆ»è¡¨ç®¡ç†ã®åˆ†é›¢
* **ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£**: Kafkaãƒ»Redis Streamsã«ã‚ˆã‚‹é«˜ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆå‡¦ç†

#### 5.3 æ€§èƒ½ãƒ»ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£è¦ä»¶
* **åŒæ™‚æ¥ç¶š**: 100-1000äºº/ãƒãƒƒãƒ—å¯¾å¿œ
* **é›»è»Šé‹è¡Œ**: 100-5000ç·¨æˆåŒæ™‚é‹è¡Œ
* **ãƒ¬ã‚¹ãƒãƒ³ã‚¹**: ä½ç½®æ›´æ–°30fpsã€æ“ä½œåæ˜ <100ms
* **å¯ç”¨æ€§**: 99.9%ç¨¼åƒç‡ç›®æ¨™

#### 5.4 ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¦ä»¶
* **å”èª¿ãƒ»ç«¶åˆãƒ¢ãƒ¼ãƒ‰**: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é–“ç›¸äº’ä½œç”¨
* **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åŒæœŸ**: WebSocketãƒ»WebRTCã«ã‚ˆã‚‹ä½ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·é€šä¿¡
* **æ¨©å¨åˆ†æ•£ã‚·ã‚¹ãƒ†ãƒ **: å®‰å…¨æ€§å„ªå…ˆã®éšå±¤çš„åˆ¶å¾¡

## ãƒ‡ãƒ¼ã‚¿è¡¨ç¾æˆ¦ç•¥ï¼ˆãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰å‹ï¼‰

ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ã€**ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰å‹ãƒ‡ãƒ¼ã‚¿è¡¨ç¾**ã‚’æ¡ç”¨ã—ã€ç”¨é€”ã«å¿œã˜ã¦æœ€é©ãªæŠ€è¡“ã‚’é¸æŠã—ã¾ã™ï¼š

- **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿**: Redis + Jackson ã«ã‚ˆã‚‹ JSON ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºï¼ˆ30fpsæ›´æ–°å¯¾å¿œï¼‰
- **æ°¸ç¶šåŒ–ãƒ‡ãƒ¼ã‚¿**: PostgreSQL + JPAï¼ˆACIDä¿è¨¼ã€ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç®¡ç†ï¼‰
- **ã‚µãƒ¼ãƒ“ã‚¹é–“é€šä¿¡**: Protocol Buffersï¼ˆå‹å®‰å…¨æ€§ã€åŠ¹ç‡æ€§ï¼‰

## å¿…è¦ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ è¨­è¨ˆ

### 1. ç·šè·¯ã‚·ã‚¹ãƒ†ãƒ ãƒ‡ãƒ¼ã‚¿æ§‹é€ 

#### 1.1 æ°¸ç¶šåŒ–ç”¨ãƒ‡ãƒ¼ã‚¿æ§‹é€ ï¼ˆPostgreSQL + JPAï¼‰

```java
// ç·šè·¯ã‚»ã‚°ãƒ¡ãƒ³ãƒˆï¼ˆæ°¸ç¶šåŒ–ï¼‰
@Entity
@Table(name = "track_segments")
@Cacheable
public class TrackSegment {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private String segmentId;
    
    // å¹¾ä½•æƒ…å ±
    @Convert(converter = CurvePointsConverter.class)
    @Column(columnDefinition = "JSONB")
    private List<Point3D> curve;          // æ›²ç·šåº§æ¨™åˆ—
    
    @Column(nullable = false)
    private double length;                // ã‚»ã‚°ãƒ¡ãƒ³ãƒˆé•·
    
    @Column(nullable = false)
    private double maxSpeed;              // æœ€å¤§é€Ÿåº¦åˆ¶é™
    
    // æ¥ç¶šæƒ…å ±
    @Column(name = "start_junction_id")
    private String startJunctionId;      // é–‹å§‹æ¥ç¶šç‚¹
    
    @Column(name = "end_junction_id")
    private String endJunctionId;        // çµ‚äº†æ¥ç¶šç‚¹
    
    // æ‰€æœ‰ãƒ»åˆ¶å¾¡æƒ…å ±
    @Column(name = "owner_id", nullable = false)
    private String ownerId;              // æ‰€æœ‰ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
    
    // ä¿¡å·åˆ¶å¾¡ï¼ˆåˆ¥ãƒ†ãƒ¼ãƒ–ãƒ«ã¨ã®ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
    @OneToMany(mappedBy = "segment", cascade = CascadeType.ALL)
    @JsonManagedReference
    private List<Signal> signals;        // é…ç½®ä¿¡å·æ©Ÿ
    
    // ç›£æŸ»ç”¨
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    private LocalDateTime updatedAt;
    
    @Version
    private Long version;                // æ¥½è¦³çš„ãƒ­ãƒƒã‚¯
}

// ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ çŠ¶æ…‹ç®¡ç†ç”¨ï¼ˆRedisï¼‰
@Data
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = "type")
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonIgnoreProperties(ignoreUnknown = true)
public class TrackSegmentState {
    @JsonProperty("segmentId")
    private String segmentId;
    
    @JsonProperty("isOccupied")
    private boolean isOccupied;          // å æœ‰çŠ¶æ…‹
    
    @JsonProperty("occupyingTrainId")
    private String occupyingTrainId;     // å æœ‰ä¸­é›»è»ŠID
    
    @JsonProperty("nodeId")
    private String nodeId;               // å‡¦ç†ãƒãƒ¼ãƒ‰ID
    
    @JsonProperty("lastUpdate")
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    private Instant lastUpdate;          // æœ€çµ‚æ›´æ–°æ™‚åˆ»
}

// æ¥ç¶šç‚¹ï¼ˆåˆ†å²ãƒ»åˆæµï¼‰
@Entity
@Table(name = "junctions")
@Cacheable
public class Junction {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private String junctionId;
    
    @Embedded
    private Location position;
    
    @Convert(converter = StringListConverter.class)
    @Column(columnDefinition = "JSONB")
    private List<String> connectedSegments;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private JunctionType type;           // MERGE, SPLIT, CROSS
    
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    private LocalDateTime updatedAt;
}

// ä¿¡å·æ©ŸçŠ¶æ…‹ï¼ˆãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ï¼‰
@Data
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonIgnoreProperties(ignoreUnknown = true)
public class JunctionState {
    @JsonProperty("junctionId")
    private String junctionId;
    
    @JsonProperty("directions")
    private Map<String, SignalState> directions; // æ–¹å‘åˆ¥ä¿¡å·çŠ¶æ…‹
    
    @JsonProperty("lastUpdate")
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    private Instant lastUpdate;
}

// ä¿¡å·æ©Ÿï¼ˆæ°¸ç¶šåŒ–ï¼‰
@Entity
@Table(name = "signals")
@Cacheable
public class Signal {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private String signalId;
    
    @Embedded
    private Location position;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "segment_id")
    @JsonBackReference
    private TrackSegment segment;        // è¨­ç½®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private SignalType type;             // BLOCK, PATH, ABSOLUTE
    
    @Convert(converter = StringListConverter.class)
    @Column(columnDefinition = "JSONB")
    private List<String> protectedSegments; // ä¿è­·å¯¾è±¡ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ
    
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    private LocalDateTime updatedAt;
}

// ä¿¡å·æ©ŸçŠ¶æ…‹ï¼ˆãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ï¼‰
@Data
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonIgnoreProperties(ignoreUnknown = true)
public class SignalState {
    @JsonProperty("signalId")
    private String signalId;
    
    @JsonProperty("state")
    private SignalDisplayState state;    // RED, YELLOW, GREEN
    
    @JsonProperty("controlledBy")
    private String controlledBy;         // åˆ¶å¾¡ãƒãƒ¼ãƒ‰ID
    
    @JsonProperty("lastUpdate")
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    private Instant lastUpdate;
}
```

#### 1.2 Protocol Bufferså¯¾å¿œï¼ˆã‚µãƒ¼ãƒ“ã‚¹é–“é€šä¿¡ï¼‰

```protobuf
// proto/track.proto
syntax = "proto3";

message TrackSegmentUpdate {
    string segment_id = 1;
    bool is_occupied = 2;
    string occupying_train_id = 3;
    int64 timestamp = 4;
}

message SignalStateUpdate {
    string signal_id = 1;
    SignalDisplayState state = 2;
    string controlled_by = 3;
    int64 timestamp = 4;
}

enum SignalDisplayState {
    RED = 0;
    YELLOW = 1;
    GREEN = 2;
}
```

```java
// Javaå´ã®ProtocolBufferså¤‰æ›
@Component
public class TrackStateMapper {
    public TrackSegmentState fromProto(TrackSegmentUpdate proto) {
        TrackSegmentState state = new TrackSegmentState();
        state.setSegmentId(proto.getSegmentId());
        state.setOccupied(proto.getIsOccupied());
        state.setOccupyingTrainId(proto.getOccupyingTrainId());
        state.setLastUpdate(Instant.ofEpochMilli(proto.getTimestamp()));
        return state;
    }
    
    public TrackSegmentUpdate toProto(TrackSegmentState state) {
        return TrackSegmentUpdate.newBuilder()
            .setSegmentId(state.getSegmentId())
            .setIsOccupied(state.isOccupied())
            .setOccupyingTrainId(state.getOccupyingTrainId())
            .setTimestamp(state.getLastUpdate().toEpochMilli())
            .build();
    }
}
```

### 2. é§…ã‚·ã‚¹ãƒ†ãƒ ãƒ‡ãƒ¼ã‚¿æ§‹é€ 

#### 2.1 æ°¸ç¶šåŒ–ç”¨ãƒ‡ãƒ¼ã‚¿æ§‹é€ 

```java
// é§…ï¼ˆæ°¸ç¶šåŒ–ï¼‰
@Entity
@Table(name = "stations")
@Cacheable
public class Station {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private String stationId;
    
    // åŸºæœ¬æƒ…å ±
    @Column(nullable = false)
    private String name;
    
    @Embedded
    private Location location;
    
    @Column(name = "owner_id", nullable = false)
    private String ownerId;
    
    // æ–½è¨­æ§‹æˆï¼ˆåˆ¥ãƒ†ãƒ¼ãƒ–ãƒ«ã¨ã®ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
    @OneToMany(mappedBy = "station", cascade = CascadeType.ALL)
    @JsonManagedReference
    private List<Gate> gates;            // æ”¹æœ­
    
    @OneToMany(mappedBy = "station", cascade = CascadeType.ALL)
    @JsonManagedReference
    private List<Platform> platforms;    // ãƒ›ãƒ¼ãƒ 
    
    @OneToMany(mappedBy = "station", cascade = CascadeType.ALL)
    @JsonManagedReference
    private List<Corridor> corridors;    // é€šè·¯
    
    // å®¹é‡æƒ…å ±
    @Column(name = "total_capacity", nullable = false)
    private int totalCapacity;           // é§…å…¨ä½“å®¹é‡
    
    // æ¥ç¶šæƒ…å ±
    @Convert(converter = StringListConverter.class)
    @Column(columnDefinition = "JSONB")
    private List<String> connectedTracks; // æ¥ç¶šç·šè·¯
    
    // ç›£æŸ»ç”¨
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    private LocalDateTime updatedAt;
    
    @Version
    private Long version;
}

// é§…çŠ¶æ…‹ï¼ˆãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ï¼‰
@Data
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonIgnoreProperties(ignoreUnknown = true)
public class StationState {
    @JsonProperty("stationId")
    private String stationId;
    
    @JsonProperty("currentOccupancy")
    private int currentOccupancy;        // ç¾åœ¨åˆ©ç”¨è€…æ•°
    
    @JsonProperty("gateStates")
    private Map<String, GateState> gateStates; // æ”¹æœ­çŠ¶æ…‹
    
    @JsonProperty("platformStates")
    private Map<String, PlatformState> platformStates; // ãƒ›ãƒ¼ãƒ çŠ¶æ…‹
    
    @JsonProperty("lastUpdate")
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    private Instant lastUpdate;
}

// æ”¹æœ­ï¼ˆæ°¸ç¶šåŒ–ï¼‰
@Entity
@Table(name = "gates")
@Cacheable
public class Gate {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private String gateId;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "station_id")
    @JsonBackReference
    private Station station;
    
    @Embedded
    private Location position;
    
    @Column(nullable = false)
    private int capacity;                // åŒæ™‚é€šéå¯èƒ½äººæ•°
    
    @Column(name = "processing_time", nullable = false)
    private double processingTime;       // ä¸€äººå½“ãŸã‚Šé€šéæ™‚é–“
    
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    private LocalDateTime updatedAt;
}

// æ”¹æœ­çŠ¶æ…‹ï¼ˆãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ï¼‰
@Data
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonIgnoreProperties(ignoreUnknown = true)
public class GateState {
    @JsonProperty("gateId")
    private String gateId;
    
    @JsonProperty("waitingQueue")
    private Queue<String> waitingQueue;  // å¾…æ©Ÿåˆ—
    
    @JsonProperty("currentProcessing")
    private int currentProcessing;       // å‡¦ç†ä¸­äººæ•°
    
    @JsonProperty("lastUpdate")
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    private Instant lastUpdate;
}

// ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ï¼ˆæ°¸ç¶šåŒ–ï¼‰
@Entity
@Table(name = "platforms")
@Cacheable
public class Platform {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private String platformId;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "station_id")
    @JsonBackReference
    private Station station;
    
    @Column(name = "track_segment_id")
    private String trackSegmentId;       // æ¥ç¶šç·šè·¯
    
    @Column(nullable = false)
    private int capacity;                // åå®¹å®šå“¡
    
    @Convert(converter = DoorListConverter.class)
    @Column(columnDefinition = "JSONB")
    private List<Door> doors;            // ãƒ‰ã‚¢ä½ç½®
    
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    private LocalDateTime updatedAt;
}

// ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ çŠ¶æ…‹ï¼ˆãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ï¼‰
@Data
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonIgnoreProperties(ignoreUnknown = true)
public class PlatformState {
    @JsonProperty("platformId")
    private String platformId;
    
    @JsonProperty("currentPassengers")
    private Set<String> currentPassengers; // ç¾åœ¨ã®åˆ©ç”¨è€…
    
    @JsonProperty("isTrainPresent")
    private boolean isTrainPresent;      // é›»è»Šåœè»Šä¸­ãƒ•ãƒ©ã‚°
    
    @JsonProperty("currentTrainId")
    private String currentTrainId;       // åœè»Šä¸­é›»è»ŠID
    
    @JsonProperty("lastUpdate")
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    private Instant lastUpdate;
}
```

### 3. é›»è»Šã‚·ã‚¹ãƒ†ãƒ ãƒ‡ãƒ¼ã‚¿æ§‹é€ ï¼ˆãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰è¨­è¨ˆï¼‰

#### 3.1 æ°¸ç¶šåŒ–ç”¨ãƒ‡ãƒ¼ã‚¿æ§‹é€ 

```java
// é›»è»Šï¼ˆæ°¸ç¶šåŒ–ï¼‰
@Entity
@Table(name = "trains")
@Cacheable
public class Train {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private String trainId;
    
    // åŸºæœ¬æƒ…å ±
    @Column(name = "owner_id", nullable = false)
    private String ownerId;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private TrainType type;              // æ™®é€šã€å¿«é€Ÿã€ç‰¹æ€¥ç­‰
    
    @Column(name = "group_id")
    private String groupId;              // é›»è»Šã‚°ãƒ«ãƒ¼ãƒ—ID
    
    // ç·¨æˆæƒ…å ±ï¼ˆåˆ¥ãƒ†ãƒ¼ãƒ–ãƒ«ã¨ã®ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
    @OneToMany(mappedBy = "train", cascade = CascadeType.ALL)
    @JsonManagedReference
    private List<Car> cars;              // è»Šä¸¡ç·¨æˆ
    
    @Column(name = "total_capacity", nullable = false)
    private int totalCapacity;           // ç·å®šå“¡
    
    @Column(name = "door_count", nullable = false)
    private int doorCount;               // ç·ãƒ‰ã‚¢æ•°
    
    // é‹è¡Œæƒ…å ±
    @OneToOne(mappedBy = "train", cascade = CascadeType.ALL)
    @JsonManagedReference
    private Route assignedRoute;         // é‹è¡ŒçµŒè·¯
    
    @OneToOne(mappedBy = "train", cascade = CascadeType.ALL)
    @JsonManagedReference
    private Schedule schedule;           // é‹è¡Œã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
    
    // åˆ¶å¾¡æƒ…å ±
    @Column(name = "is_controlled_by_player")
    private boolean isControlledByPlayer; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆ¶å¾¡ãƒ•ãƒ©ã‚°
    
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    private LocalDateTime updatedAt;
    
    @Version
    private Long version;
}

// é›»è»ŠçŠ¶æ…‹ï¼ˆãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ï¼‰
@Data
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = "type")
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonIgnoreProperties(ignoreUnknown = true)
public class TrainState {
    @JsonProperty("trainId")
    private String trainId;
    
    @JsonProperty("currentState")
    private TrainOperationState currentState; // STOPPED, MOVING, BOARDING
    
    @JsonProperty("position")
    private Position position;
    
    @JsonProperty("speed")
    private double speed;                // ç¾åœ¨é€Ÿåº¦
    
    @JsonProperty("acceleration")
    private double acceleration;         // åŠ é€Ÿåº¦
    
    @JsonProperty("currentSegmentId")
    private String currentSegmentId;     // ç¾åœ¨ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ
    
    @JsonProperty("direction")
    private Direction direction;         // é€²è¡Œæ–¹å‘
    
    @JsonProperty("passengers")
    private Set<String> passengers;      // ä¹—å®¢IDé›†åˆ
    
    @JsonProperty("controllingNodeId")
    private String controllingNodeId;    // åˆ¶å¾¡ãƒãƒ¼ãƒ‰ID
    
    @JsonProperty("lastUpdate")
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    private Instant lastUpdate;
    
    // Jackson/Proto ä¸¡å¯¾å¿œ
    public String toJson() {
        try {
            ObjectMapper mapper = new ObjectMapper();
            return mapper.writeValueAsString(this);
        } catch (Exception e) {
            throw new RuntimeException("JSON serialization failed", e);
        }
    }
}
```

#### 3.2 Protocol Bufferså¯¾å¿œ

```protobuf
// proto/train.proto
syntax = "proto3";

message TrainPositionUpdate {
    string train_id = 1;
    double x = 2;
    double y = 3;
    double speed = 4;
    double acceleration = 5;
    string current_segment_id = 6;
    Direction direction = 7;
    int64 timestamp = 8;
}

message TrainStateUpdate {
    string train_id = 1;
    TrainOperationState state = 2;
    repeated string passengers = 3;
    string controlling_node_id = 4;
    int64 timestamp = 5;
}

enum TrainOperationState {
    STOPPED = 0;
    MOVING = 1;
    BOARDING = 2;
    EMERGENCY = 3;
}

enum Direction {
    FORWARD = 0;
    BACKWARD = 1;
}
```

### 4. ä½æ°‘ã‚·ã‚¹ãƒ†ãƒ ãƒ‡ãƒ¼ã‚¿æ§‹é€ ï¼ˆECSå¯¾å¿œï¼‰

```java
// ä½æ°‘ï¼ˆshared-modelsã‹ã‚‰æ‹¡å¼µï¼‰
@Entity
@Table(name = "residents")
@Cacheable
public class Resident {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private String residentId;
    
    // åŸºæœ¬æƒ…å ±ï¼ˆæ—¢å­˜shared-modelsã¨ã®äº’æ›æ€§ï¼‰
    @Embedded
    private PersonalInfo personalInfo;   // æ—¢å­˜
    
    @Embedded
    private EconomicStatus economicStatus; // æ—¢å­˜
    
    // AIè¡Œå‹•
    @OneToOne(mappedBy = "resident", cascade = CascadeType.ALL)
    @JsonManagedReference
    private AIBehavior behavior;
    
    @OneToMany(mappedBy = "resident", cascade = CascadeType.ALL)
    @JsonManagedReference
    private List<TravelPattern> patterns; // è¡Œå‹•ãƒ‘ã‚¿ãƒ¼ãƒ³
    
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    private LocalDateTime updatedAt;
    
    @Version
    private Long version;
}

// ä½æ°‘çŠ¶æ…‹ï¼ˆãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ï¼‰
@Data
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonIgnoreProperties(ignoreUnknown = true)
public class ResidentState {
    @JsonProperty("residentId")
    private String residentId;
    
    @JsonProperty("currentTravelPlan")
    private TravelPlan currentTravelPlan; // æ—¢å­˜
    
    @JsonProperty("currentPosition")
    private Position currentPosition;
    
    @JsonProperty("state")
    private ResidentActivityState state; // WAITING, TRAVELING, AT_DESTINATION
    
    @JsonProperty("assignedNodeId")
    private String assignedNodeId;       // å‡¦ç†ãƒãƒ¼ãƒ‰ID
    
    @JsonProperty("lastUpdate")
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    private Instant lastUpdate;
}
```

### 5. ãƒ•ã‚§ãƒ¼ã‚ºåˆ¥å®Ÿè£…æˆ¦ç•¥

#### Phase 1: ãƒ¢ãƒãƒªã‚¹æœŸï¼ˆJackson + Redis + PostgreSQLï¼‰

```java
// Redisè¨­å®š
@Configuration
public class RedisConfig {
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);
        
        Jackson2JsonRedisSerializer<Object> serializer = 
            new Jackson2JsonRedisSerializer<>(Object.class);
        
        ObjectMapper mapper = new ObjectMapper();
        mapper.registerModule(new JavaTimeModule());
        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        serializer.setObjectMapper(mapper);
        
        template.setDefaultSerializer(serializer);
        return template;
    }
}

// ã‚µãƒ¼ãƒ“ã‚¹å®Ÿè£…ä¾‹
@Service
@Transactional
public class TrainStateService {
    @Autowired
    private RedisTemplate<String, TrainState> redisTemplate;
    
    @Autowired
    private TrainRepository trainRepository;
    
    @Cacheable(value = "trainStates", key = "#trainId")
    public TrainState getTrainState(String trainId) {
        String key = "train:state:" + trainId;
        return redisTemplate.opsForValue().get(key);
    }
    
    public void updateTrainState(TrainState state) {
        String key = "train:state:" + state.getTrainId();
        redisTemplate.opsForValue().set(key, state, Duration.ofSeconds(30));
        
        // éåŒæœŸã§ã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œ
        applicationEventPublisher.publishEvent(new TrainStateUpdatedEvent(state));
    }
}
```

#### Phase 2: ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹æœŸï¼ˆProtocol Buffersè¿½åŠ ï¼‰

```java
// gRPCã‚µãƒ¼ãƒ“ã‚¹å®Ÿè£…
@GrpcService
public class TrainPositionGrpcService extends TrainPositionServiceGrpc.TrainPositionServiceImplBase {
    
    @Autowired
    private TrainStateService trainStateService;
    
    @Autowired
    private TrainStateMapper mapper;
    
    @Override
    public void updatePosition(TrainPositionUpdate request, 
                              StreamObserver<TrainPositionResponse> responseObserver) {
        TrainState state = mapper.fromProto(request);
        trainStateService.updateTrainState(state);
        
        TrainPositionResponse response = TrainPositionResponse.newBuilder()
            .setSuccess(true)
            .setTimestamp(System.currentTimeMillis())
            .build();
            
        responseObserver.onNext(response);
        responseObserver.onCompleted();
    }
}
```

#### Phase 3: å¤§è¦æ¨¡å¯¾å¿œæœŸï¼ˆæœ€é©åŒ–ï¼‰

```java
// é«˜é€Ÿãƒã‚¤ãƒŠãƒªã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
@Component
public class OptimizedTrainStateSerializer {
    private final Kryo kryo = new Kryo();
    
    @PostConstruct
    public void init() {
        kryo.register(TrainState.class);
        kryo.register(Position.class);
        kryo.setReferences(false);
    }
    
    public byte[] serialize(TrainState state) {
        try (Output output = new Output(256, -1)) {
            kryo.writeObject(output, state);
            return output.toBytes();
        }
    }
    
    public TrainState deserialize(byte[] data) {
        try (Input input = new Input(data)) {
            return kryo.readObject(input, TrainState.class);
        }
    }
}

// ç©ºé–“ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚­ãƒ£ãƒƒã‚·ãƒ¥
@Service
public class SpatialCacheService {
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Cacheable(value = "spatialIndex", key = "#bounds.toString()")
    public List<String> getEntitiesInBounds(BoundingBox bounds) {
        // Redisã®åœ°ç†ç©ºé–“ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½¿ç”¨
        String key = "spatial:entities";
        return redisTemplate.opsForGeo()
            .radiusByMember(key, bounds.getCenter(), 
                           Distance.of(bounds.getRadius(), DistanceUnit.KILOMETERS))
            .getContent()
            .stream()
            .map(result -> result.getContent().getName())
            .collect(Collectors.toList());
    }
}
```

### 6. æŠ€è¡“é¸æŠã¾ã¨ã‚

| ç”¨é€” | Phase 1 | Phase 2 | Phase 3 |
|------|---------|---------|---------|
| ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿ | Jackson + Redis | + Protocol Buffers | + Kryoæœ€é©åŒ– |
| æ°¸ç¶šåŒ–ãƒ‡ãƒ¼ã‚¿ | JPA + PostgreSQL | + èª­ã¿å–ã‚Šå°‚ç”¨ãƒ¬ãƒ—ãƒªã‚« | + åˆ†æ•£DB |
| ã‚µãƒ¼ãƒ“ã‚¹é–“é€šä¿¡ | REST API | gRPC + Protocol Buffers | + è² è·åˆ†æ•£ |
| ã‚­ãƒ£ãƒƒã‚·ãƒ¥ | Spring Cache | + åˆ†æ•£ã‚­ãƒ£ãƒƒã‚·ãƒ¥ | + ç©ºé–“ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ |
| ã‚¤ãƒ™ãƒ³ãƒˆé…ä¿¡ | Spring Events | Kafka + Jackson | + ãƒã‚¤ãƒŠãƒªåœ§ç¸® |

ã“ã®æ®µéšçš„ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒã«ã‚ˆã‚Šã€å„ãƒ•ã‚§ãƒ¼ã‚ºã§å¿…è¦ãªæ€§èƒ½ã¨ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£ã‚’ç¢ºä¿ã—ãªãŒã‚‰ã€æŠ€è¡“çš„è² å‚µã‚’æœ€å°åŒ–ã—ãŸå®Ÿè£…ãŒå¯èƒ½ã§ã™ã€‚

## DDDã‚¢ãƒ—ãƒ­ãƒ¼ãƒã«ãŠã‘ã‚‹æ¥­å‹™ãƒ­ã‚¸ãƒƒã‚¯é…ç½®æŒ‡é‡

### 1. å„å±¤ã®å½¹å‰²ã¨è²¬å‹™

å…±é€šãƒ¢ãƒ‡ãƒ«ï¼ˆpackages/shared-modelsï¼‰

```java
// âœ… é©åˆ‡ãªä½¿ç”¨ä¾‹
@Data
public class Track {
    private String id;
    private double length;
    private double maxSpeed;

    // ãƒ“ã‚¸ãƒã‚¹ãƒ«ãƒ¼ãƒ«ã®ã¿ - æ°¸ç¶šåŒ–ã‚„ã‚¤ãƒ³ãƒ•ãƒ©ä¾å­˜ãªã—
    public boolean canAccommodateSpeed(double requestedSpeed) {
        return requestedSpeed <= maxSpeed;
    }

    public boolean isLongEnough(double minimumLength) {
        return length >= minimumLength;
    }
}
```

Entityï¼ˆJPAæ°¸ç¶šåŒ–ãƒ¢ãƒ‡ãƒ«ï¼‰

```java
// âœ… é©åˆ‡ãªä½¿ç”¨ä¾‹
@Entity
public class TrackEntity implements Serializable {
    // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ§‹é€ ã¨ãƒãƒƒãƒ”ãƒ³ã‚°ã®ã¿
    // ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã¯å«ã¾ãªã„
    @Id private String id;
    @Column private Double length;
    @OneToMany private List<SignalEntity> signals;
}
```

### 2. æ¥­å‹™ãƒ­ã‚¸ãƒƒã‚¯å®Ÿè£…å ´æ‰€ã®æŒ‡é‡

ã€Œç·šè·¯ã‚’å»¶é•·ã™ã‚‹ã€ãƒ­ã‚¸ãƒƒã‚¯ã®å®Ÿè£…

```java
// ğŸ¯ ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚µãƒ¼ãƒ“ã‚¹å±¤ã§ã®å®Ÿè£…
@Service
@Transactional
public class TrackExtensionService {

    private final TrackRepository trackRepository;
    private final JunctionRepository junctionRepository;
    private final TrackMapper trackMapper;

    /**
    * ç·šè·¯å»¶é•·ã®è¤‡é›‘ãªæ¥­å‹™ãƒ­ã‚¸ãƒƒã‚¯
    */
    public Track extendTrack(String trackId, double extensionLength, Point3D endPoint) {
        // 1. ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒ«ã§æ¥­å‹™ãƒ«ãƒ¼ãƒ«æ¤œè¨¼
        Track track = findTrackOrThrow(trackId);

        if (!track.canBeExtended(extensionLength)) {
            throw new TrackExtensionNotAllowedException("Track cannot be extended beyond maximum length");
        }

        // 2. è¤‡é›‘ãªæ¥­å‹™ãƒ­ã‚¸ãƒƒã‚¯å®Ÿè¡Œ
        Junction newJunction = createJunctionAt(endPoint);
        Track extendedTrack = track.extend(extensionLength, newJunction.getId());

        // 3. æ°¸ç¶šåŒ–ï¼ˆã‚¤ãƒ³ãƒ•ãƒ©å±¤ã¸ç§»è­²ï¼‰
        TrackEntity savedEntity = trackRepository.save(trackMapper.toEntity(extendedTrack));
        return trackMapper.toDomain(savedEntity);
    }
}
```

ã€Œãƒ›ãƒ¼ãƒ ã‚’å¢—ã‚„ã™ã€ãƒ­ã‚¸ãƒƒã‚¯ã®å®Ÿè£…

```java
// ğŸ¯ é›†ç´„ãƒ«ãƒ¼ãƒˆï¼ˆStationï¼‰ã§ã®èª¿æ•´
@Service
@Transactional
public class StationExpansionService {

    /**
    * é§…ã¸ã®ãƒ›ãƒ¼ãƒ è¿½åŠ ï¼ˆé›†ç´„å†…ã®æ•´åˆæ€§ä¿è¨¼ï¼‰
    */
    public Station addPlatform(String stationId, Platform newPlatform) {
        Station station = findStationOrThrow(stationId);

        // ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒ«ã§ã®åˆ¶ç´„ãƒã‚§ãƒƒã‚¯
        if (!station.canAccommodateNewPlatform(newPlatform)) {
            throw new PlatformCapacityExceededException("Station capacity exceeded");
        }

        // é›†ç´„å†…ã§ã®çŠ¶æ…‹å¤‰æ›´
        Station updatedStation = station.addPlatform(newPlatform);

        return stationRepository.save(stationMapper.toEntity(updatedStation))
            .let(stationMapper::toDomain);
    }
}
```

### 3. ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆ¥è²¬å‹™ãƒãƒˆãƒªãƒƒã‚¯ã‚¹

| æ“ä½œ       | å…±é€šãƒ¢ãƒ‡ãƒ« | Entity | Repository | Service | Controller |
|----------|-------|--------|------------|---------|------------|
| ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼    | âœ…     | âŒ      | âŒ          | âœ…       | âŒ          |
| æ¥­å‹™ãƒ«ãƒ¼ãƒ«    | âœ…     | âŒ      | âŒ          | âœ…       | âŒ          |
| æ°¸ç¶šåŒ–      | âŒ     | âœ…      | âœ…          | âŒ       | âŒ          |
| ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ | âŒ     | âŒ      | âŒ          | âœ…       | âŒ          |
| APIå¤‰æ›    | âŒ     | âŒ      | âŒ          | âŒ       | âœ…          |

## MapStructãƒãƒƒãƒ‘ãƒ¼å®Ÿè£…æˆ¦ç•¥

è‡ªå‹•å®Ÿè£… vs ã‚«ã‚¹ã‚¿ãƒ å®Ÿè£…

MapStructã«ã‚ˆã‚‹è‡ªå‹•ç”Ÿæˆï¼ˆæ¨å¥¨ï¼‰:
```java
// ç¾åœ¨ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ â†’ è‡ªå‹•å®Ÿè£…ã•ã‚Œã‚‹
@Mapper(componentModel = "spring")
public interface StationMapper {
    Station toDomain(StationEntity entity);
    StationEntity toEntity(Station domain);
}

// ãƒ“ãƒ«ãƒ‰æ™‚ã«ä»¥ä¸‹ãŒè‡ªå‹•ç”Ÿæˆã•ã‚Œã‚‹:
// StationMapperImpl.java
```

è¤‡é›‘ãªãƒãƒƒãƒ”ãƒ³ã‚°ãŒå¿…è¦ãªå ´åˆ:
```java
@Mapper(componentModel = "spring", uses = {LocationMapper.class})
public interface TrackMapper {

    @Mapping(target = "signals", source = "signals")
    @Mapping(target = "curve", qualifiedByName = "mapCurvePoints")
    Track toDomain(TrackEntity entity);

    // ã‚«ã‚¹ã‚¿ãƒ ãƒãƒƒãƒ”ãƒ³ã‚°ãƒ¡ã‚½ãƒƒãƒ‰
    @Named("mapCurvePoints")
    default List<Point3D> mapCurvePoints(List<Point3DEmbeddable> entities) {
        return entities.stream()
            .sorted(Comparator.comparing(Point3DEmbeddable::getSequenceOrder))
            .map(this::mapPoint3D)
            .collect(Collectors.toList());
    }

    Point3D mapPoint3D(Point3DEmbeddable entity);
}
```

æ¨å¥¨å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³:

1. åŸºæœ¬ãƒãƒƒãƒ”ãƒ³ã‚°: MapStructè‡ªå‹•ç”Ÿæˆã«å§”è­²
2. è¤‡é›‘ãªå¤‰æ›: @Namedãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚«ã‚¹ã‚¿ãƒ å®Ÿè£…
3. validation: ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒ«å†…ã§å®Ÿè£…
4. ç‰¹æ®Šã‚±ãƒ¼ã‚¹: å°‚ç”¨Serviceã‚„Factoryã‚¯ãƒ©ã‚¹ä½œæˆ

ã“ã‚Œã‚‰ã®æ–¹é‡ã«ã‚ˆã‚Šã€DDDã®åŸå‰‡ã‚’ä¿ã¡ãªãŒã‚‰åŠ¹ç‡çš„ãªå®Ÿè£…ãŒå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚
